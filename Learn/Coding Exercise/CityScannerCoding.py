# -*- coding: utf-8 -*-
"""CityScannerCoding.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1b9xtYbH3v4x5yRVWvKSbmAL1Kz5yimSH

![download.png](data:image/png;base64,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)

 ## **CityScanner: Introduction to Hyperlocal Environmental Sensing**


---

##Overview
Engaging with and analyzing environmental data is a powerful tool to better understand the world around you. This notebook shows how to:

*  Create time series graphs
*  Develop basic maps with environmental data
*   Perform clustering analysis on pollution hotspots

##Part 0: Setup

Here, we are going to call Python libraries - modules of code that allow us to have different types of functionality in our program.
"""

# Commented out IPython magic to ensure Python compatibility.
# #Block 1
# #here, we install the tool we are going to use to make some maps, called Folium 
# %%capture
# !pip install folium

#Block 2
#this block of code is where we get the infrastructure for the notebook set up, by calling libraries
import csv
import numpy as np

#these libraries will help us read in and format the data correctly
import pytz
import time
import pandas as pd
from datetime import datetime
import os

#these libraries will help us with our time series analysis
from matplotlib import pyplot as plt
from matplotlib import ticker as mticker
import matplotlib.dates as mdates

#these libraries will support the mapping work
import folium 
from folium import plugins
import branca.colormap as cm
from matplotlib.dates import DateFormatter
from sklearn.cluster import DBSCAN
from geopy.distance import great_circle
from shapely.geometry import MultiPoint

"""## Part 1 -Time Series

Now, we will read in the data from a CityScanner deployment in The Bronx, New York City. You can switch out the below example files with data from your own deployments in the future!
"""

#Block 3

#below are the files for temp/humidity, PM and NO2 data. 
th = "NYC_Pilot1.csv"
pm = "NYC_Pilot2_PM_Part1.csv"
no2 = "NYC_Pilot2_NO2_Part1.csv"

#the line of code below reads in the data file for temperature and humidity data!
thdata = pd.read_csv(th, engine='python') #contents of data
pmdata = pd.read_csv(pm, engine='python') #contents of data
no2data = pd.read_csv(no2, engine='python') #contents of data

"""Then we set the timezone so the code knows what it is, and print ourselves a message to verify we read it in correctly."""

#Block 4
tz = pytz.timezone('US/Eastern')
print("Data read")

#Block 5

#here, we will show the first few lines of the data files. Check out what the start date and times are! 
thdata.head()

#uncomment the line below to see the start of the PM data file!
#pmdata.head()

#uncomment the line below to see the start of the NO2 data file!
#no2data.head()

#Block 6
#here, we will show the last few lines of the data files. Check out what the ending date and times are! 
thdata.tail()

#uncomment the line below to see the end of the PM data file!
#pmdata.tail()

#uncomment the line below to see the end of the NO2 data file!
#no2data.tail()

"""Time to warm up with a map. Let's find some parameters from the deployment in time series - let's start with temperature and then try PM2.5! 

Let's get some basic information about temperature from this deployment - 
- The average temperature the devices saw
- The maximum temperatures the devices saw
- The minimum temperature the devices saw 
"""

#Block 7
avg = pmdata['temperature'].mean()
max = pmdata['temperature'].max()
min = pmdata ['temperature'].min()


#now that we have those values, let's print them out so we can take a look
print("Avg value",avg, "Max value",max, "Min value",min)


#th file variable names
#temperature, humidity

#pm file variable names
#pm25

#no2 file variable names 
#no2

"""Now let's make a plot of the total temperature during the time we have collected the data for."""

#Block 8
fig, ax = plt.subplots(figsize=(20, 8))
plt.plot(thdata["time"], thdata["temperature"], 'r')
ax.set(xlabel="time",
       ylabel="Temp(C)",
       title="Time Series")
tick_spacing = 6000
ax.xaxis.set_major_locator(mticker.MultipleLocator(tick_spacing))
plt.xticks(rotation=45);
plt.show()

#Block 9
#this is a helpful image, but what if we just want to know the time series for one week, or another period of time?
#we can select the time we want to create a time series for using the code below.


fig, ax = plt.subplots(figsize=(20, 8))
plt.plot(thdata["time"], thdata["temperature"], 'r')

ax.set(xlabel="time",
       ylabel="Temp(C)",
       title="Time Series",
       xlim=["2021/11/02 09:33", "2021/11/02 09:42"]) #set the time range you are interested in using in the square brackets!
tick_spacing = 20                                                     #play with this number to increase or decrease the number of x axis labels
ax.xaxis.set_major_locator(mticker.MultipleLocator(tick_spacing))
plt.xticks(rotation=45);
plt.show() 

#you can modify the pm and no2 files using a similar structure as above!

"""Great - now replace the temperature parameters with humidity, and even pm2.5 or no2 from the other data files. Rerun the code and see what you get! What does the data tell you?

## Part 2 - Mapping + Hotspot Analysis

Now that we created some time series graphs, we will work on creating maps. Let's start with a PM2.5 map!
"""

#Block 10
#we're going to make a map. we start by setting a center point for the map to display the data
coords = pmdata.loc[:,['lat','long']].values #lat and lon are collected from CityScanner GPS
start_point=coords[0]

#Block 11
#here, we set up the specifications for the map
newmap = folium.Map(location= start_point, tiles='Stamen Terrain', zoom_start=14)
colormap = cm.LinearColormap(colors=['blue', 'green', 'yellow'], vmin=0, vmax=21)
colormap.caption = 'PM 2.5 (ug/m^3)' #change this to represent the variable of interest! 
colormap.add_to(newmap)


#this will loop through the data and show us where it's coming from
#each point on the map will display the PM2.5 value from that spot, in micrograms per cubic meter.
for i,row in pmdata.iterrows():
    #folium.CircleMarker((row.lat,row.long), radius=4, weight=1, color='blue', fill_color='blue', fill_opacity=.5, popup=(row.pm25)).add_to(newmap)
    folium.CircleMarker((row.lat,row.long), radius=4, weight=1, color=colormap(pmdata.iloc[i]['pm25']), fill ='true', fill_opacity=.5, popup=(row.pm25)).add_to(newmap)

newmap.add_child(colormap)
#here we save an html version of the map - you can zoom in and out of it and interact with it!
#this .html file will be saved to your google drive folder. Download it to your computer and open it to interact with it! 
newmap.save('newmap.html')
#you may need to refresh the page on your google drive folder to see the updated map! 
#you may also need to close a few tabs so you don't run out of memory when opening the map :)


#note - you can also create a map for a subset of the total deployment time by calling the "thdatamod", "pmdatamod", or "no2datamod" variable above!

"""Now that we have our point map, showing us where pm2.5 values and potential hotspot locations are, let's do some clustering. This will allow us to see where multiple measurements exceed the threshold value, potentially indicating a local source of pollution or pollution transport."""

#Block 12
#let's start by setting 10 as the threshold value. Change this and see how the number of hotspots changes! 
pmdata = pmdata.loc[(pmdata['pm25'] > 10)]

#Block 13
#hierarchical clustering code 

# bottom-up hierarchical clustering - agglomerative, not k-means, because number of clusters not defined before
hotspots = pmdata 
coords = hotspots.loc[:,['lat','long']].values

#preprocessing for hotspot clustering
#we have to convert to radians, because scikit-learnâ€™s haversine metric needs radian units
kms_per_radian = 6371.0088 

#epsilon is the max distance points can be from each other to count as a cluster
epsilon = 0.1 / kms_per_radian 

#min_samples is the minimum cluster size for a hotspot to be formed, and here we also call the haversine metric
db = DBSCAN(eps=epsilon, min_samples=10, algorithm='ball_tree', metric='haversine').fit(np.radians(coords))
cluster_labels = db.labels_
num_clusters = len(set(cluster_labels))-(1 if -1 in set(cluster_labels) else 0)
outliers = coords[cluster_labels == -1]

#here is where we create the clusters after doing the background math above
clusters = pd.Series([coords[cluster_labels == n] for n in range(num_clusters)])
outliers = coords[cluster_labels == -1]
print('Number of clusters: {}'.format(num_clusters))

#Block 14
#this portion of the code is going to tell us where the map should show up!

def get_centermost_point(cluster):
    centroid = (MultiPoint(cluster).centroid.x, MultiPoint(cluster).centroid.y)
    centermost_point = min(cluster, key=lambda point: great_circle(point, centroid).m)
    return tuple(centermost_point)
                                      
                                      
centermost_points = clusters.map(get_centermost_point)
start_point=centermost_points[0]

#setting up the specifications for the map
hotspotmap = folium.Map(location= start_point, tiles='Stamen Terrain', zoom_start=14)
points=[]
#add a markers
for index, row in hotspots.iterrows():
    point=(row['lat'] row['long'])
    if point not in points:
        new_point=(row['lat'], row['long'])
        points.append(new_point)      
for rep in centermost_points:
    folium.CircleMarker(location=rep, color='blue', fill=True, fill_color='blue',radius=15).add_to(hotspotmap)
for each in points:
    folium.CircleMarker(location=each, popup=(row.pm25), color='red', fill=True, fill_color='red',radius=7).add_to(hotspotmap)
    hotspotmap.add_child(folium.LatLngPopup())
  

#interactive html map showing hotspot clusters
hotspotmap.save('HotspotMap.html')

"""##Summary
Now that you have finished going through this notebook, you should be able to create time series graphs, basic maps, and perform clustering analysis techniques on hyperlocal environmental data. Additionally, you should have a basic knowledge of some of the different pollutants that can be measured to tell us more about the quality of our immediate environment.

##Resources and references
Below you can find links to some of the CityScanner papers, some of the reference materials shown in the presentation, and some reference documentation for some of the python libraries!

CityScanner Papers:
*   [Challenges of Drive-By IoT Sensing for Smart Cities: City Scanner Case Study](https://senseable.mit.edu/papers/pdf/20181012_Anjomshooa-etal_ChallengesDrive-by_Purba.pdf)
*  [ City Scanner: Building and Scheduling a Mobile
Sensing Platform for Smart City Services](https://senseable.mit.edu/papers/pdf/20180522_Anjomshoaa-etal_CityScanner_IEEE-IoT.pdf)
* [Air quality monitoring using mobile low-cost sensors mounted on trashtrucks: Methods development and lessons learned](https://senseable.mit.edu/papers/pdf/20200601_deSouza-etal_AirQuality_SCS.pdf)

Reference Materials:
*  [NYCCAS Data](https://nyc-ehs.net/nyccas2020/web/report#Pollutant_Maps)
*  [United States EPA](https://www.epa.gov/)
*  [World Health Organization](https://www.who.int/)

Python Library Documentation:
*  [Folium](http://python-visualization.github.io/folium/)
*  [Pandas](https://pandas.pydata.org/)
* [Matplotlib](https://matplotlib.org/)
"""